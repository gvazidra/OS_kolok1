# Коллоквиум №1
# Чиж Елена 2 курс, 11 группа
# Вариант 2

--- 

## 1.  Приведите Win API, необходимое для решения Лабораторной работы номер 2

```cpp
// Создание потока
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
   SIZE_T                  dwStackSize,
    LPTHREAD_START_ROUTINE  lpStartAddress,
    LPVOID                  lpParameter,
    DWORD                   dwCreationFlags,
    LPDWORD                 lpThreadId
);

// Ожидание завершения потока
DWORD WaitForSingleObject(
    HANDLE hHandle,
    DWORD  dwMilliseconds
);
// Пример использования:
WaitForSingleObject(hAverage, INFINITE);

// Засыпание (задержка потока)
VOID Sleep(
    DWORD dwMilliseconds
);
// Пример использования:
Sleep(12);
```

---

## 2. Что такое процесс в ОС Windows

Процесс в операционной системе Windows — это объект ядра, которому принадлежат системные ресурсы, используемые приложением. Процесс — это экземпляр выполняемой программы.

### Основные характеристики процесса:
- Процесс имеет собственное виртуальное адресное пространство.
- Выполнение процесса начинается с **первичного потока** (main thread).
- Процесс может создавать дополнительные потоки во время выполнения.
- Процесс управляется системой с помощью **идентификатора** и **дескриптора**.

### Жизненный цикл процесса:
1. **Создание** — через функцию `CreateProcess`.
2. **Выполнение** — выполняется основной поток и другие потоки, если созданы.
3. **Завершение** — процесс завершает работу после завершения всех своих потоков или через системные вызовы.

### Прототип функции для создания процесса:

```cpp
BOOL CreateProcess(
    LPCTSTR lpApplicationName,      // имя исполняемого модуля
    LPTSTR lpCommandLine,           // командная строка
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // атрибуты защиты процесса
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // атрибуты защиты потока
    BOOL bInheritHandles,           // наследование дескрипторов
    DWORD dwCreationFlags,          // флаги создания процесса
    LPVOID lpEnvironment,           // указатель на блок новой среды окружения
    LPCTSTR lpCurrentDirectory,     // текущий каталог
    LPSTARTUPINFO lpStartupInfo,    // указатель на структуру STARTUPINFO
    LPPROCESS_INFORMATION lpProcessInformation // указатель на структуру PROCESS_INFORMATION
);
```
### Пример создания процесса:

```cpp
STARTUPINFO si;
PROCESS_INFORMATION pi;
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);

if (CreateProcess(
        "C:\\Program.exe", // путь к исполняемому файлу
        NULL,              // параметры командной строки
        NULL,              // защита процесса
        NULL,              // защита потока
        FALSE,             // наследование дескрипторов
        CREATE_NEW_CONSOLE,// создание новой консоли
        NULL,              // окружение
        NULL,              // текущий каталог
        &si,               // информация о запуске
        &pi))              // информация о процессе
{
    // Ждем завершения процесса
    WaitForSingleObject(pi.hProcess, INFINITE);
    // Закрываем дескрипторы
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

```

### Примеры завершения процесса:

- Завершение процесса самим собой:
```cpp
VOID ExitProcess(
    UINT uExitCode // код возврата для всех потоков
);
// Пример использования:
ExitProcess(0);
```

- Завершение процесса извне:
```cpp
BOOL TerminateProcess(
    HANDLE hProcess, // дескриптор процесса
    UINT uExitCode   // код завершения процесса
);
// Пример использования:
TerminateProcess(hProcess, 1);
```

### Особенности:
- Процессы могут создавать дочерние процессы, которые после запуска работают независимо.
- Каждому процессу выделяется изолированное виртуальное адресное пространство для защиты от сбоев других процессов.
- Завершение основного (первичного) потока приводит к завершению всего процесса.
- Использование TerminateProcess должно быть оправдано, так как оно не освобождает все ресурсы корректно (применяется только в аварийных ситуациях).

---

## 3. Что такое Критическая секция

Критическая секция в Windows — это механизм синхронизации, который обеспечивает **взаимное исключение доступа** нескольких потоков к общему ресурсу внутри одного процесса. Она используется для того, чтобы только один поток мог выполнять определённый участок кода (критическую секцию) в каждый момент времени.

### Проблема

При параллельной работе нескольких потоков возможна ситуация, когда два или более потоков одновременно обращаются к одному и тому же ресурсу (например, переменной или файлу). Это приводит к **состояниям гонки** и ошибкам в работе программы.

### Решение

Для предотвращения таких проблем критическая секция:
- Блокирует доступ к ресурсу для других потоков, пока текущий поток не завершит работу с ним.
- Обеспечивает **быструю синхронизацию** в пределах одного процесса (не между разными процессами).

### API для работы с критическими секциями

```cpp
// Инициализация критической секции
VOID InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Вход в критическую секцию (ожидает освобождения, если занята)
VOID EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Проверка возможности войти без ожидания
BOOL TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Выход из критической секции
VOID LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Удаление критической секции
VOID DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);
```

## Пример использования
```cpp
CRITICAL_SECTION cs;

void ThreadFunction() {
    EnterCriticalSection(&cs);
    // Критическая секция: доступ к общему ресурсу
    // ...
    LeaveCriticalSection(&cs);
}

int main() {
    InitializeCriticalSection(&cs);

    // Создание потоков и работа...

    DeleteCriticalSection(&cs);
    return 0;
}
```

## Особенности
- Критическая секция эффективна только внутри одного процесса. Для синхронизации между процессами нужно использовать другие объекты (например, мьютексы).
- Функция TryEnterCriticalSection позволяет попытаться войти в критическую секцию без блокировки — она возвращает TRUE, если вход выполнен успешно, и FALSE, если критическая секция занята.
- Этот механизм не является объектом ядра Windows и работает быстрее, чем объекты синхронизации ядра (например, мьютексы), при работе в пределах одного процесса.
