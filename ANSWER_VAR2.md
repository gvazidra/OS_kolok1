# Коллоквиум №1
# Чиж Елена 2 курс, 11 группа
# Вариант 2

--- 

## 1.  Приведите Win API, необходимое для решения Лабораторной работы номер 2

```cpp
// Создание потока
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
   SIZE_T                  dwStackSize,
    LPTHREAD_START_ROUTINE  lpStartAddress,
    LPVOID                  lpParameter,
    DWORD                   dwCreationFlags,
    LPDWORD                 lpThreadId
);

// Ожидание завершения потока
DWORD WaitForSingleObject(
    HANDLE hHandle,
    DWORD  dwMilliseconds
);
// Пример использования:
WaitForSingleObject(hAverage, INFINITE);

// Засыпание (задержка потока)
VOID Sleep(
    DWORD dwMilliseconds
);
// Пример использования:
Sleep(12);
```

---

## 2. Что такое процесс в ОС Windows

Процесс в операционной системе Windows — это объект ядра, которому принадлежат системные ресурсы, используемые приложением. Процесс — это экземпляр выполняемой программы.

### Основные характеристики процесса:
- Процесс имеет собственное виртуальное адресное пространство.
- Выполнение процесса начинается с первичного потока (main thread).
- Процесс может создавать дополнительные потоки во время выполнения.
- Процесс управляется системой с помощью идентификатора и дескриптора.

### Жизненный цикл процесса:
1. **Создание** — через функцию `CreateProcess`.
2. **Выполнение** — выполняется основной поток и другие потоки, если созданы.
3. **Завершение** — процесс завершает работу после завершения всех своих потоков или через системные вызовы.

### Прототип функции для создания процесса:

```cpp
BOOL CreateProcess(
    LPCTSTR lpApplicationName,      // имя исполняемого модуля
    LPTSTR lpCommandLine,           // командная строка
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // атрибуты защиты процесса
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // атрибуты защиты потока
    BOOL bInheritHandles,           // наследование дескрипторов
    DWORD dwCreationFlags,          // флаги создания процесса
    LPVOID lpEnvironment,           // указатель на блок новой среды окружения
    LPCTSTR lpCurrentDirectory,     // текущий каталог
    LPSTARTUPINFO lpStartupInfo,    // указатель на структуру STARTUPINFO
    LPPROCESS_INFORMATION lpProcessInformation // указатель на структуру PROCESS_INFORMATION
);
```
### Пример создания процесса:

```cpp
STARTUPINFO si;
PROCESS_INFORMATION pi;
ZeroMemory(&si, sizeof(si));
si.cb = sizeof(si);

if (CreateProcess(
        "C:\\Program.exe", // путь к исполняемому файлу
        NULL,              // параметры командной строки
        NULL,              // защита процесса
        NULL,              // защита потока
        FALSE,             // наследование дескрипторов
        CREATE_NEW_CONSOLE,// создание новой консоли
        NULL,              // окружение
        NULL,              // текущий каталог
        &si,               // информация о запуске
        &pi))              // информация о процессе
{
    // Ждем завершения процесса
    WaitForSingleObject(pi.hProcess, INFINITE);
    // Закрываем дескрипторы
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

```

### Примеры завершения процесса:

- Завершение процесса самим собой:
```cpp
VOID ExitProcess(
    UINT uExitCode // код возврата для всех потоков
);
// Пример использования:
ExitProcess(0);
```

- Завершение процесса извне:
```cpp
BOOL TerminateProcess(
    HANDLE hProcess, // дескриптор процесса
    UINT uExitCode   // код завершения процесса
);
// Пример использования:
TerminateProcess(hProcess, 1);
```

### Особенности:
- Процессы могут создавать дочерние процессы, которые после запуска работают независимо.
- Каждому процессу выделяется изолированное виртуальное адресное пространство для защиты от сбоев других процессов.
- Завершение основного (первичного) потока приводит к завершению всего процесса.
- Использование `TerminateProcess` должно быть оправдано, так как оно не освобождает все ресурсы корректно (применяется только в аварийных ситуациях).

---

## 3. Что такое Критическая секция

Критическая секция в Windows — это механизм синхронизации, который обеспечивает взаимное исключение доступа нескольких потоков к общему ресурсу внутри одного процесса. Она используется для того, чтобы только один поток мог выполнять определённый участок кода (критическую секцию) в каждый момент времени.

### Проблема

При параллельной работе нескольких потоков возможна ситуация, когда два или более потоков одновременно обращаются к одному и тому же ресурсу (например, переменной или файлу). Это приводит к состояниям гонки и ошибкам в работе программы.

### Решение

Для предотвращения таких проблем критическая секция:
- Блокирует доступ к ресурсу для других потоков, пока текущий поток не завершит работу с ним.
- Обеспечивает быструю синхронизацию в пределах одного процесса (не между разными процессами).

### API для работы с критическими секциями

```cpp
// Инициализация критической секции
VOID InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Вход в критическую секцию (ожидает освобождения, если занята)
VOID EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Проверка возможности войти без ожидания
BOOL TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Выход из критической секции
VOID LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

// Удаление критической секции
VOID DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);
```

## Пример использования
```cpp
CRITICAL_SECTION cs;

void ThreadFunction() {
    EnterCriticalSection(&cs);
    // Критическая секция: доступ к общему ресурсу
    // ...
    LeaveCriticalSection(&cs);
}

int main() {
    InitializeCriticalSection(&cs);

    // Создание потоков и работа...

    DeleteCriticalSection(&cs);
    return 0;
}
```

## Особенности
- Критическая секция эффективна только внутри одного процесса. Для синхронизации между процессами нужно использовать другие объекты (например, мьютексы).
- Функция `TryEnterCriticalSection` позволяет попытаться войти в критическую секцию без блокировки — она возвращает `TRUE`, если вход выполнен успешно, и `FALSE`, если критическая секция занята.
- Этот механизм не является объектом ядра Windows и работает быстрее, чем объекты синхронизации ядра (например, мьютексы), при работе в пределах одного процесса.

---

## 4. Что такое Семафор

Семафор в Windows — это объект синхронизации, который используется для управления доступом нескольких потоков к ограниченному числу ресурсов. В отличие от критической секции, которая разрешает доступ только одному потоку, семафор может разрешать доступ нескольким потокам одновременно, до заданного лимита.

### Принцип работы

Семафор содержит внутренний счетчик, который:
- Уменьшается при каждом захвате ресурса потоком.
- Увеличивается при освобождении ресурса.

Пока счетчик больше нуля, потоки могут продолжать захватывать ресурс. Если счетчик достигает нуля, последующие потоки будут заблокированы до тех пор, пока другие потоки не освободят ресурс.

### Пример задачи для семафора

Например, у вас есть пул из 3 подключений к базе данных. Вы хотите, чтобы максимум 3 потока одновременно использовали эти подключения. Семафор позволяет управлять этим доступом.

### API для работы с семафором

```cpp
// Создание семафора
HANDLE CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
);

// Ожидание доступа к ресурсу через семафор
DWORD WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
);

// Освобождение семафора (увеличение счетчика)
BOOL ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
);

// Закрытие дескриптора семафора
CloseHandle(hSemaphore);
```

## Пример использования
```cpp
HANDLE hSemaphore;

void ThreadFunction() {
    // Ждем доступ к ресурсу (уменьшение счетчика)
    WaitForSingleObject(hSemaphore, INFINITE);

    // Критическая секция: работа с ограниченным ресурсом
    // ...

    // Освобождаем семафор (увеличение счетчика)
    ReleaseSemaphore(hSemaphore, 1, NULL);
}

int main() {
    // Создаем семафор с максимальным счетчиком 3 и начальным значением 3
    hSemaphore = CreateSemaphore(NULL, 3, 3, NULL);

    // Создаем потоки и работаем...

    // Завершаем
    CloseHandle(hSemaphore);
    return 0;
}
```

## Особенности
- Семафоры поддерживают синхронизацию как внутри одного процесса, так и между разными процессами (если указать имя в параметре `lpName` при создании).
- В отличие от мьютексов и критических секций, семафор может позволять нескольким потокам одновременно захватывать ресурс.
- Если значение счетчика семафора равно нулю, потоки, вызывающие `WaitForSingleObject`, будут блокироваться до тех пор, пока другой поток не вызовет `ReleaseSemaphore`.

---

## 5. Сравнительный анализ стандартов C++ в контексте лабораторной работы

Рассмотрим сравнение возможностей стандартов C++ для реализации лабораторной работы с потоками и синхронизацией.

### C++98 без Boost

- Нет встроенной поддержки многопоточности.
- Для работы с потоками и синхронизацией необходимо использовать низкоуровневые средства, такие как WinAPI функции:
  - `CreateThread`
  - `WaitForSingleObject`
  - `Sleep`
  - `InitializeCriticalSection`
  - `EnterCriticalSection`
- Код становится привязанным к платформе (Windows), сложнее в написании и поддержке.

### C++98 с Boost

- Библиотека Boost предоставляет кроссплатформенные средства для многопоточности:
  - `boost::thread`
  - `boost::mutex`
  - `boost::lock_guard`
- Позволяет писать более читаемый и переносимый код, избегая прямой зависимости от WinAPI.
- Boost значительно облегчает синхронизацию и управление потоками по сравнению с использованием WinAPI напрямую.
- Компиляция сложнее из-за зависимости от внешней библиотеки.

### C++11 и новее без Qt

- Стандарт языка включает встроенные средства многопоточности:
  - `std::thread`
  - `std::mutex`
  - `std::unique_lock`
  - `std::condition_variable`
- Код становится кроссплатформенным и более чистым без сторонних зависимостей.
- Примеры:
  - Создание потока: `std::thread t(f);`
  - Ожидание завершения потока: `t.join();`
- Отличный выбор для консольных приложений без GUI.

### C++11 и новее с Qt

- Qt предоставляет собственные высокоуровневые классы:
  - `QThread`
  - `QMutex`
  - `QSemaphore`
  - `QWaitCondition`
- Глубокая интеграция с GUI и событийной моделью Qt делает многопоточность удобной в интерфейсных приложениях.
- Реализация потоков через наследование от `QThread` или использование паттернов с сигналами и слотами упрощает обработку данных в отдельных потоках без блокировки главного интерфейса.
- Qt позволяет также удобно управлять жизненным циклом объектов в многопоточной среде.

### Итог

- C++98 без Boost подходит только в случае, если требуется строгое соблюдение старого стандарта и нет возможности использовать сторонние библиотеки. Однако реализация потоков и синхронизации при этом низкоуровневая и сложная.
- Использование Boost делает работу с потоками проще и кроссплатформенной, но требует подключения библиотеки.
- C++11 и новее предоставляют все необходимые инструменты на уровне языка, что упрощает код и снижает зависимость от сторонних библиотек.
- Qt целесообразно применять при создании GUI-приложений, где требуется интеграция многопоточности с интерфейсом.

В контексте лабораторной работы (консольное приложение с потоками) оптимальным выбором является использование возможностей стандарта C++11 и новее, так как это позволяет писать простой и переносимый код без внешних зависимостей.
